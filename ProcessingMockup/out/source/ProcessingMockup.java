/* autogenerated by Processing revision 1293 on 2024-04-18 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.Map;
import java.util.ArrayList;
import java.util.List;
import java.util.HashMap;
import java.util.Map;
import java.util.HashMap;
import java.util.Map;
import java.util.Map;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.HashSet;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class ProcessingMockup extends PApplet {

// We can use an observer pattern for a renderer that updates the screen on a timer or something
// All rendering objects 'listen' to the game clock

// Singleton for settings? Such as boid radius, etc. this is a good sub for a lut
// default settings like default boid color, etc and then just choie of boid color on top of that like user defined but can reset to normal

EventManager eventManager; // this should eventually be created in the world and be dependency injected all the way down as needed, specifically to system entity managers
PGraphics scene;
EntityManager entityManager;
RenderSystem renderSystem;
PhysicsSystem physicsSystem;


public void mousePressed() {
  println("Mouse Pressed");
  entityManager.buildEntity()
    .with(new Transform(mouseX, mouseY))
    .with(new Renderer(new CircleRenderFunction()))
    .with(new Tag("circle"))
    .with(new RigidBody())
    .create();
}

public void setup() {

  println("Setup");

  /* size commented out by preprocessor */;
  scene = createGraphics(width, height);
  
  eventManager = new EventManager();
  entityManager = new EntityManager(eventManager);
  renderSystem = new RenderSystem(eventManager, scene);
  physicsSystem = new PhysicsSystem(eventManager);
  
  drawBackground();
  
}

public void draw() {
  // For each boid
  // Do the rules it needs to do
  // Then render
  
  // update
  
  physicsSystem.update(.01f);
  

  scene.beginDraw();
  scene.background(0);
  renderSystem.update(1);
  scene.endDraw();

  image(scene, 0, 0);
  
  
}

public void drawBackground() {
  background(0xFF9CBFED);
}
//// Interface for collision behavior
//interface CollisionBehavior {
//    boolean collidesWith(GameObject other);
//}
public interface Component {

  /* Description:
   Components are added to entities to compose behavior from small parts.
   */

  /* Method to initialize the component:
   Performs initialization tasks when the component is attached to an entity
   */
  default void initialize() {
  }

  /* Method to clean up the component:
   Performs cleanup tasks when the component is removed from an entity.
   This include removing observers, preventing memory leaks, etc.
   */
  default void cleanup() {
  }
}

// Tags provide a unique identification system of entity types. This is to distinguish two entities that are different but share the same set of components
public class Tag implements Component {
  private String tag;

  public Tag() {
    this.setTag("default");
  }

  public Tag(String tag) {
    this.setTag(tag);
  }

  public String getTag() {
    return tag;
  }

  public void setTag(String tag) {
    this.tag = tag.toLowerCase();
  }
}

public class Transform implements Component {

  protected PVector position;
  protected PVector direction;
  protected PVector scale;

  // Position
  public PVector getPosition() {
    return position.copy();
  }
  public PVector getDirection() {
    return direction.copy();
  }

  public PVector getScale() {
    return scale.copy();
  }

  public Transform() {
    this.position = new PVector(0, 0);
    this.direction = new PVector(0, 1);
    this.scale = new PVector(1, 1);
  }

  public Transform(float initialX, float initialY) {
    this.position = new PVector(initialX, initialY);
    this.direction = new PVector(0, 1);
    this.scale = new PVector(1, 1);
  }

  public Transform(PVector initialPosition, PVector initialDirection) {
    this.position = initialPosition.copy();
    this.direction = initialDirection.copy();
    this.scale = new PVector(1, 1);
  }

  public void setPosition(PVector position) {
    this.position = position;
  }

  public void setDirection(PVector direction) {
    this.direction = direction.normalize(); // Ensure the vector is normalized
  }

  public void setScale(PVector scale) {
    this.scale = scale;
  }

  public void moveBy(PVector moveAmount) {
    setPosition(PVector.add(this.position, moveAmount));
  }

  public void rotateBy(float angle) {
    direction.rotate(angle);
  }
}


/* Component interface for rendering behavior:
 TODO: Make this more portable to other non processing systems, aka an abstract class and an extended processing specific renderer
 */
public class Renderer implements Component {

  private RenderFunction renderFunction;

  public Renderer(RenderFunction renderFunction) {
    this.renderFunction = renderFunction;
  }

  // Make set render function / get render function / remove render function

  public void render(PGraphics renderContext, Transform transform) {
    println("In render component.render");
    if (renderFunction != null) {
      renderFunction.render(renderContext, transform);
    }
  }
}


public class RigidBody implements Component {
  
  private PVector velocity = new PVector(0,0);
  private PVector acceleration = new PVector(0,0);
  private float mass = 1;
  
  public boolean isStatic = false;
  
  public RigidBody() {
    // Empty default constructor
    // TODO make a few more constuctors for init velocity and mass, no init acceleration
    // TODO make a few more changes to also allow for creation of static bodies.
  }
  
  public void applyForce(PVector force) {
    if (isStatic) return;
    PVector forceAcc = PVector.div(force, mass);
    acceleration.add(forceAcc);
  }
  
  public void update(int deltaTime) {
    
    if (isStatic) return;
    velocity.add(PVector.mult(acceleration, deltaTime));
    acceleration.mult(0); // Clear acc after each update, i guess unless it is gravity but we aint doing that, there is a better way to do this i think
    
  }
  
  public PVector getVelocity() {
    return this.velocity.copy();
  }
  
}


public class Entity {

  /* Description:
   Entity is an object that can have components. Components are handled and define
   all of the behavior we want. The big picture of this approach is to facor composition
   over inheritance to reduce dependencies. For example a Boid gameObject is a gameObject
   that would have components that give its behavior, rendering, collisions, etc.
   Research ECS pattern for details.
   */

  // ---------- Entity Member Variables ---------- //

  /* ID System:
   The unique ID of is made and handled in the manager
   */
  private int id;

  /* Components:
   We store the gameObject components as a map, and use componentType as a LUT.
   This solves the problem of handling duplicate components (no duplicates allowed)
   and lets us find a given component in O(1) time!
   */
  private Map<Class<? extends Component>, Component> components = new HashMap<>();

  private Set<String> tags = new HashSet<>(); // Multiple tags


  // ---------- Constructor ---------- //
  public Entity(int id) {
    this.id = id;
  }
  // TODO upgrade tag system to make it so we can shove it in on constructor
  //public Entity(int id) {
  //  this.id = id;
  //}


  // ---------- Component Handling ---------- //

  /* DESCRIPTION:
   Components are attached to the game entity. For instance if an entity is renderable, we attach a
   'renderable' compoent to the object. This allows us to define the scope and behavior of each entity on instantiation.
   The components attached to a given entity are typically done in the entityManager.
   Components are stored in a map for O(1) look up time.
   */

  // addComponent (with instance of component)
  public <T extends Component> void addComponent(T component) {
    components.put(component.getClass(), component);
    component.initialize();
  }

  // removeComponent (by component class)
  public <T extends Component> void removeComponent(Class<T> componentClass) {
    Component component = components.remove(componentClass);
    component.cleanup();
  }

  // getComponent (by component class)
  public <T extends Component> T getComponent(Class<T> componentClass) {
    return componentClass.cast(components.get(componentClass));
  }

  // hasComponent (of component class) T/F
  public <T extends Component> boolean hasComponent(Class<T> componentClass) {
    return components.containsKey(componentClass);
  }

  public List<Component> getComponents() {
    return (List)components.values();
  }

  // ---------- Tag Handling ---------- //
  public void addTag(String tag) {
    tags.add(tag);
  }
  public void removeTag(String tag) {
    tags.remove(tag);
  }

  public boolean hasTag(String tag) {
    return tags.contains(tag);
  }

  public Set<String> getTags() {
    return new HashSet<>(tags); // Return a copy to maintain encapsulation
  }

  public void cleanup() {
    for (Component component : components.values()) {
      removeComponent(component.getClass());
    }
  }

  public int getID() {
    return this.id;
  }
}



public class EntityBuilder {
  private final EntityManager entityManager;
  private final Entity entity;
  private final List<Component> componentsToNotify;  // List to store components temporarily


  // When builder is constructed in the context of the entity manager class, we create new entity with the genrated id
  public EntityBuilder(EntityManager entityManager, int entityId) {
    this.entityManager = entityManager;
    this.entity = new Entity(entityId);
    this.componentsToNotify = new ArrayList<>();

    //// Transform and Tag components are being added by default
    //Transform defaultTransform = new Transform();  // Example: create a default transform
    //Tag defaultTag = new Tag("default");  // Example: create a default tag
    //this.componentsToNotify.add(defaultTransform);
    //this.componentsToNotify.add(defaultTag);

    // TODO add transform and tag components by default since all entities should have a default tag and a transform.
    println("Building Entity");
  }

  // Add methods to configure the entity as needed
  public EntityBuilder with(Component component) {
    println("With Component: " + component.getClass().getSimpleName());
    // TODO make this so all of the events are done after create is called in a buffer IMPORTANT
    this.entity.addComponent(component);
    this.componentsToNotify.add(component);
    return this;
  }

  // Method to build and return the created entity
  public Entity create() {
    
    entityManager.addEntity(entity);

    for (Component component : componentsToNotify) {
      eventManager.notifySubscribers(new ComponentAddedEvent(entity, component));
    }

    return entity;
  }
}
 //<>//


// TODO Explain later, main idea is give entity an id so they can be stored in LUT
// We have serveral things to help run the game more like create destroy and modify components of a game object



public class EntityManager {
  private int nextEntityId = 0;
  private Map<Integer, Entity> entities = new HashMap<>();

  private EventManager eventManager;

  public EntityManager(EventManager eventManager) {
    this.eventManager = eventManager;
  }


  // ---------- Entity Creation ---------- //

  // Create a new entity with an automatically generated ID
  public EntityBuilder buildEntity() {
    return new EntityBuilder(this, nextEntityId++);
  }

  // Method to add the created entity to the entity manager
  public void addEntity(Entity entity) {
    entities.put(entity.getID(), entity);
  }

  // Delete an entity by removing it from the map
  public void deleteEntity(int entityId) {
    Entity entity = entities.remove(entityId);
    if (entity == null) return;

    for (Component component : entity.getComponents()) {
      // TODO remove component and unsubscibe them
    }

    entity.cleanup();
  }

  // ---------- Entity Management ---------- //


  // Attach a component to an entity
  // Note absense of checks for duplicates. this should be okay bc of datastructures using, but dont attach component more than once bro.
  public <T extends Component> void attachComponent(int entityId, T component) {
    println("Attach component");

    Entity entity = entities.get(entityId);
    if (entity == null) return;

    // can be thought of set component, can explore this later to make it clearer and avoid resetting if that is a concern
    entity.addComponent(component);
    
    println("Notifying Subscribers of Component Added");
    eventManager.notifySubscribers(new ComponentAddedEvent(entity, component));
    
  }
  
  

  // Remove a component from an entity
  public <T extends Component> void removeComponent(int entityId, Class<T> componentClass) {
    
    Entity entity = entities.get(entityId);
    if (entity == null) return;
    
    Component component = entity.getComponent(componentClass);
    eventManager.notifySubscribers(new ComponentRemovedEvent(entity, component));
    entity.removeComponent(componentClass);

  }

  // Get a component attached to an entity // TODO might need to make some error catching
  public <T extends Component> T getComponent(int entityId, Class<T> componentClass) {

    Entity entity = entities.get(entityId);

    return (entity != null)? entity.getComponent(componentClass) : null;
  }

  public Entity getEntityByID(int entityID) {
    // Check map for given ID
    Entity entity = entities.get(entityID);
    // Handle the case where the specified ID does not exist // MAYBE JUST RETURN NULL???? TODO FOR FUTURE DECISION
    if (entity == null) throw new IllegalArgumentException("No entity found with ID: " + entityID);
    return entity;
  }

  // this is for testing should not be used, breaks encapsulation
  public Map<Integer, Entity> TestingGetEntities() {
    return this.entities;
  }
}




public interface Event {
  // Define methods common to all events, havent decided on this yet
}

//// Types of events:
//public class CollisionEvent implements Event {
//    // Add properties specific to collision events
//}

//public class InteractionEvent implements Event {
//    // Add properties specific to interaction events
//}\


public class ComponentEvent implements Event {
  private Entity entity;                                // The entity from which the event originates
  private Component component;                          // The component involved in the event
  private Set<String> associatedTags;                   // A set of tags associated with the entity
  private Class<? extends Component> componentClass;

  public ComponentEvent(Entity entity, Component component) {
    this.entity = entity;
    this.component = component;
    this.componentClass = component.getClass();
    this.associatedTags = entity.getTags();
  }

  public Entity getEntity() {
    return entity;
  }

  public Component getComponent() {
    return component;
  }

  public Class<? extends Component> getComponentClass() {
    return this.componentClass;
  }

  public Set<String> getTags() {
    return associatedTags;
  }

  public boolean isComponentType(Class<? extends Component> type) {
    return type.isInstance(component);
  }

  public boolean hasTags(String... requiredTags) {
    Set<String> entityTags = entity.getTags();
    return Arrays.stream(requiredTags).allMatch(entityTags::contains);
  }
}

public class ComponentAddedEvent extends ComponentEvent {
  public ComponentAddedEvent(Entity entity, Component component) {
    super(entity, component);
  }
}

public class ComponentRemovedEvent extends ComponentEvent {
  public ComponentRemovedEvent(Entity entity, Component component) {
    super(entity, component);
  }
}






public interface EventListener {
  void handleEvent(Event event);
}

public class EventManager {
  private Map<Class<? extends Event>, List<EventListener>> subscribers = new HashMap<>();

  public void subscribe(Class<? extends Event> eventType, EventListener listener) {
    subscribers.computeIfAbsent(eventType, k -> new ArrayList<>()).add(listener);
  }

  public void unsubscribe(Class<? extends Event> eventType, EventListener listener) {
    List<EventListener> listeners = subscribers.get(eventType);

    if (listeners == null) return;

    listeners.remove(listener);
    
    if (listeners.isEmpty()) subscribers.remove(eventType);
  }

  public void notifySubscribers(Event event) {
    List<EventListener> listeners = subscribers.get(event.getClass());

    if (listeners == null) return;

    for (EventListener listener : listeners) {
      listener.handleEvent(event);
    }
  }
}
//public interface BoidBehavior {

//  PVector calculateMovement(Boid boid, ArrayList<Boid> neighbors);
//}

//public class FlockBehavior implements BoidBehavior {
//  public PVector calculateMovement(Boid boid, ArrayList<Boid> neighbors) {
//    // Calculate movement direction based on all flocking rules:
    
//    PVector separationForce = new PVector(0,0);
//    PVector cohesionForce = new PVector(0,0);
//    PVector alignmentForce = new PVector(0,0);
    
//    // Calculate Separation Force:
//    // separationForce = new PVector(1,0);
    
//    // Calculate Cohesion Force:


//    // Calculate Alignment Force:



//    // Calculate and add net force:
//    PVector netForce = separationForce.add(cohesionForce).add(alignmentForce);
//    return netForce;
//  }
//}


//public class SeparationBehavior implements BoidBehavior {
//  public PVector calculateMovement(Boid boid, ArrayList<Boid> neighbors) {
//    // Calculate movement direction based on separation rule
//    return new PVector();
//  }
//}

//public class AlignmentBehavior implements BoidBehavior {
//  public PVector calculateMovement(Boid boid, ArrayList<Boid> neighbors) {
//    // Calculate movement direction based on alignment rule
//    return new PVector();
//  }
//}

//public class CohesionBehavior implements BoidBehavior {
//  public PVector calculateMovement(Boid boid, ArrayList<Boid> neighbors) {
//    // Calculate movement direction based on cohesion rule
//    return new PVector();
//  }
//}

//// Circle behavior class
//class CircleBehavior implements BoidBehavior {
//  private float angularSpeed;

//  CircleBehavior(float angularSpeed) {
//    this.angularSpeed = angularSpeed;
//  }

//  public PVector calculateMovement(Boid boid, ArrayList<Boid> neighbors) {
//    // Calculate movement to make the boid turn in a circle
//    PVector rotation = boid.velocity.copy().rotate(HALF_PI); // Perpendicular to velocity
//    rotation.normalize().mult(angularSpeed); // Set magnitude
//    return rotation;
//  }
//}

public interface RenderFunction {
  void render(PGraphics renderContext, Transform transform);
}

public class CircleRenderFunction implements RenderFunction {



  public void render(PGraphics renderContext, Transform transform) {
    println("In CircleRenderFunction");

    PVector pos = transform.getPosition();
    PVector dir = transform.getDirection();
    PVector scale = transform.getScale();

    println("In CircleRenderFunction PASSED ASSIGNMENT");


    int primaryColor = color(180, 30, 70);

    renderContext.push();
    println("In CircleRenderFunction renderContext.push();");

    renderContext.fill(primaryColor);
    renderContext.circle(pos.x, pos.y, 15f);
    renderContext.pop();
  }
}
// Interface for renderable game objects



// ---------- Renderable Component ---------- //
/* Description:
 Describes the render behavior of a gameObject. Attach this component with a corresponding 'RenderFunction'
 to describe the specifics of how to render the object.
 */
 
//interface Renderable extends Component {
//  void render();
//  void setRenderFunction(RenderFunction<?> renderFunction);
//}



//// ---------- Render Function ---------- //
///*
//TODO: Elaborate on dynamic typing and any specifics
//*/

//// Function interface for rendering game objects
//interface RenderFunction<T> {
//  void render(T gameObject);
//}

//class SimpleBoid implements RenderFunction<Boid> {
//  public void render(Boid boid) {

//    PVector pos = boid.position;
//    PVector vel = boid.velocity.copy();
//    PVector velDir = vel.copy().normalize();

//    // TODO, this is just for testing, will eventually move these vars to better encapsulate
//    color primaryColor = color(000000);
//    float size = 15f;

//    stroke(0);
//    strokeWeight(1.5);
//    fill(primaryColor);
//    circle(pos.x, pos.y, size);

//    fill(255);
//    circle(pos.x+(3*velDir.x), pos.y+(3*velDir.y), 7f);

//    // temp direction showing
//    stroke(color(255, 0, 0));
//    line(pos.x, pos.y, pos.x + vel.x * 10f, pos.y + vel.y * 10f);
//  }
//}

//class SimpleBoidDebug implements RenderFunction<Boid> {
//  public void render(Boid boid) {

//    PVector pos = boid.position;
//    PVector vel = boid.velocity.copy();
//    PVector velDir = vel.copy().normalize();

//    // TODO, this is just for testing, will eventually move these vars to better encapsulate
//    color primaryColor = color(000000);
//    float size = 15f;

//    stroke(0);
//    strokeWeight(1.5);
//    fill(primaryColor);
//    circle(pos.x, pos.y, size);

//    fill(255);
//    circle(pos.x+(3*velDir.x), pos.y+(3*velDir.y), 7f);

//    push();
//    noStroke();
//    fill(153, 255, 153, 80);
//    circle(pos.x, pos.y, boid.getPerceptionRadius());

//    pop();


//    // temp direction showing
//    stroke(color(255, 0, 0));
//    line(pos.x, pos.y, pos.x + vel.x * 10f, pos.y + vel.y * 10f);
//  } 
//}
 //<>//


public abstract class System {
  protected EventManager eventManager;

  public System(EventManager eventManager) {
    this.eventManager = eventManager;

    // Lambdas for event
    this.eventManager.subscribe(ComponentAddedEvent.class, event -> handleComponentAdded(event));
    this.eventManager.subscribe(ComponentRemovedEvent.class, event -> handleComponentRemoved(event));
  }
  private void handleComponentAdded(Event event) {
    if (event instanceof ComponentAddedEvent && matchesSystemCriteria((ComponentEvent) event)) {
      onComponentAdded(((ComponentEvent) event).getEntity(), ((ComponentEvent) event).getComponent());
    }
  }

  private void handleComponentRemoved(Event event) {
    if (event instanceof ComponentRemovedEvent && matchesSystemCriteria((ComponentEvent) event)) {
      onComponentRemoved(((ComponentEvent) event).getEntity(), ((ComponentEvent) event).getComponent());
    }
  }

  // Abstract methods to be implemented by concrete systems
  protected abstract boolean matchesSystemCriteria(ComponentEvent event);
  protected abstract void onComponentAdded(Entity entity, Component component);
  protected abstract void onComponentRemoved(Entity entity, Component component);

  public abstract void update(float deltaTime);
}

// Finally im coding and it doesnt have to be perfect
public class RenderSystem extends System {

  public PGraphics renderContext;

  // ID - Component pairs -> Decouples entity from the system - component calculation
  private Map<Integer, Transform> transforms = new HashMap<>();
  private Map<Integer, Renderer> renderers = new HashMap<>();

  public RenderSystem(EventManager eventManager, PGraphics renderContext) {
    super(eventManager);
    this.renderContext = renderContext;
  }

  @Override
    protected boolean matchesSystemCriteria(ComponentEvent event) {
    return event.isComponentType(Renderer.class);
  }

  @Override
    protected void onComponentAdded(Entity entity, Component component) {
    Integer ID = entity.getID();
    transforms.put(ID, entity.getComponent(Transform.class));
    renderers.put(ID, (Renderer)component);
    println("Adding id:" + ID + " to renderers.");
  }

  @Override
    protected void onComponentRemoved(Entity entity, Component component) {
    // Implementation for removing a component from the rendering system
  }

  @Override
    public void update(float deltaTime) {
    for (Integer id : renderers.keySet()) {
      println("Updating rendererSystem (in loop) : " + id);
      Renderer renderer = this.renderers.get(id);
      Transform transform = this.transforms.get(id);

      if ((renderer == null) || (transform == null)) continue; // TODO ben, make this print a warning / return an exception

      renderer.render(renderContext, transform);
    }
  }
}


// Finally im coding and it doesnt have to be perfect
public class PhysicsSystem extends System {

  // ID - Component pairs -> Decouples entity from the system - component calculation
  private Map<Integer, Transform> transforms = new HashMap<>();
  private Map<Integer, RigidBody> rigidBodies = new HashMap<>();

  public PhysicsSystem(EventManager eventManager) {
    super(eventManager);
  }

  @Override
    protected boolean matchesSystemCriteria(ComponentEvent event) {
    return event.isComponentType(RigidBody.class);
  }

  @Override
    protected void onComponentAdded(Entity entity, Component component) {
    Integer ID = entity.getID();
    transforms.put(ID, entity.getComponent(Transform.class));
    rigidBodies.put(ID, (RigidBody)component);
    println("Adding id:" + ID + " to rigidbody.");
  }

  @Override
    protected void onComponentRemoved(Entity entity, Component component) {
    // Implementation for removing a component from the rendering system // todo for ben
  }

  @Override
    public void update(float deltaTime) {
    println("Updating physicsSystem");
    for (Integer id : rigidBodies.keySet()) {

      RigidBody rigidBody = this.rigidBodies.get(id);
      Transform transform = this.transforms.get(id);
      

      if ((rigidBody == null) || (transform == null)) continue; // TODO for ben, do the same thing for this one.
      
      rigidBody.applyForce(new PVector(1,0) );
      
      rigidBody.update(1);
      
      PVector velocity = rigidBody.getVelocity();
      PVector moveAmount = PVector.mult(rigidBody.getVelocity(), deltaTime);
      
      transform.moveBy(moveAmount);
      
    }
  }
}


  public void settings() { size(1600, 1000); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "ProcessingMockup" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
