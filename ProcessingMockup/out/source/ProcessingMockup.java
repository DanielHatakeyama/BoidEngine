/* autogenerated by Processing revision 1293 on 2024-04-17 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class ProcessingMockup extends PApplet {

// We can use an observer pattern for a renderer that updates the screen on a timer or something
// All rendering objects 'listen' to the game clock

// Singleton for settings? Such as boid radius, etc. this is a good sub for a lut
// default settings like default boid color, etc and then just choie of boid color on top of that like user defined but can reset to normal

ArrayList<Boid> boids = new ArrayList<>();    


//public void createBoids(int n) {
//  for (int i=0; i<n; i++) {
//    createBoid();
//  }
//}


public void createBoid(PVector pos) {
  PVector randVelocity = PVector.random2D().mult(2f);
  
  Boid b = new Boid(pos, randVelocity, new FlockBehavior());
  
  boids.add(b);
}
public void mousePressed() {
  PVector mousePos = new PVector(mouseX, mouseY);
  createBoid(mousePos);
}

public void setup() {
    /* size commented out by preprocessor */;
    
    for (int i = 0; i<500; i++) {
      PVector randomPosition = new PVector(random(width), random(height));
      createBoid(randomPosition);
    }
}


public void draw() {
  // For each boid
  // Do the rules it needs to do
  // Then render
  drawBackground();
  drawBoids();
}



public void drawBoids() {
  for(Boid b : boids) {
    b.update(boids);
    b.render();
  }
}
public void drawBackground() {
  background(0xFF9CBFED);
}

class Boid extends GameObject {


  // Implements renderable game object perhaps that would mean all i have to do is define a shape or something for the boid and the render and update functions are implemented with this in mind, i can also change the "sprite"
  // for cases like debuging vision radius

  // Implement with behavior, or whatever else needed to make work oop style

  // Look parameters (Radius)
  // Speed Parameters
  // (Constant, what speed, what accel?)
  // Die parameters
  // Color Parameters
  // Behaviors

  // SIMULATE EVOLUTION WITH FISH FLOCKING BEHAVIORS AND WHAT IS THE BEST STRATEGY!!!

  // for now do constant velocity idc about anything



  private PVector mass; // This will eventually act as a multiplier on acceleration so we can make behavior heavy or lighter responsive
  private int primaryColor;
  private float size = 15f;
  private PVector faceDirection; // Is velocity vector most of the time i think i cant think of a counter ex
  private float maxSpeed = 5f;
  private float maxForce = 0.5f;
  // Turning speed

  private float perceptionRadius = 180f;

  private BoidBehavior behavior;


  // Simple default for now boid
  Boid(PVector initPosition, PVector initVelocity, BoidBehavior behavior) {
    //
    this.position = initPosition;
    this.velocity = initVelocity;

    this.behavior = behavior;
    setRenderFunction(new SimpleBoidDebug());
  }

  public void update(ArrayList<Boid> boids) {

    ArrayList<Boid> neighbors = this.getNeighbors(boids);
    PVector movementForce = behavior.calculateMovement(this, neighbors);
    applyForce(movementForce);
  }

  // TODO: Make a overload in future that doesnt use all global boids
  // TODO: Make this generalized in the future
  public ArrayList<Boid> getNeighbors(ArrayList<Boid> boids) {
    // (Naive approach)

    ArrayList<Boid> Neighbors = new ArrayList<Boid>();
    
    // Loop through all boids that exist, if distance from this is < perceptionRadius, add to neighbors
    for (Boid boid : boids) {
      
      // ignore starting boid
      if (this == boid) continue;
      
      //PVector neighborPosition = boid.position;
      //float distance = sqrt(sq(this.position.x - neighborPosition.x)-sq(this.position.y - neighborPosition.y));
      float distance = PVector.dist(this.getPosition(), boid.getPosition());
      
      if (distance < perceptionRadius) {
        Neighbors.add(boid);
      }
    }

    return Neighbors;
  }

  private void applyForce(PVector force) {
    // Applys force vector in controlled way - limits force, max velocity, and wraps boid position
    //force.div(50);
    
    force.limit(maxForce);
    velocity.add(force);
    velocity.limit(maxSpeed);
    //velocity.normalize().mult(maxSpeed); // temporary make boids always go max speed
    position.add(velocity);
    //wrapPosition();
    bounceEdges();
  }

  private void wrapPosition() {
    // CODE TO BE CHANGED THIS IS BAD AND TEMPORARY:
    if (position.x > width + size) position.x = (-size);
    if (position.x < -size) position.x += (width + size);

    if (position.y > height + size) position.y = (-size);
    if (position.y < -size) position.y += (height + size);
  }
  
  private void bounceEdges() {
    
    float bounceForce = 0.5f;
    float innerBoundary = 50f; // In pixels
    
    // CODE TO BE CHANGED THIS IS BAD AND TEMPORARY:
    if (position.x > width + size - innerBoundary) this.velocity.x -= bounceForce; //applyForce(new PVector(-bounceForce,0));
    if (position.x < -size + innerBoundary) this.velocity.x += bounceForce; //applyForce(new PVector(bounceForce,0));

    if (position.y > height + size - innerBoundary) this.velocity.y -= bounceForce; //applyForce(new PVector(0,-bounceForce));
    if (position.y < -size + innerBoundary) this.velocity.y += bounceForce; //applyForce(new PVector(0,bounceForce)); // down
  }

  // Graphical Functions
  // Show vision radius
  // Show face direction vector-


  public float getMaxSpeed() {
    return this.maxSpeed;
  }

  public float getMaxForce() {
    return this.maxForce;
  }
  public float getPerceptionRadius() {
    return this.perceptionRadius;
  }
  
  public PVector getPosition() {
    return this.position.copy();
  }
  public PVector getVelocity() {
    return this.velocity.copy();
  }
}


// Extra behaviors, if not up to speed, move until at speed in a direction, searching for group
// Interface for collision behavior
interface CollisionBehavior {
    boolean collidesWith(GameObject other);
}

public abstract class GameObject<T> implements Renderable {


  protected PVector position, velocity, acceleration;

  protected RenderFunction renderFunction;
  
  protected int z = 0;

  @Override
  public void render() {
    push();
    if (renderFunction != null) renderFunction.render((T) this);
    pop();
  }

  @Override
  public void setRenderFunction(RenderFunction<?> renderFunction) {
    // Enforce type safety by checking if the render function is compatible with the type of game object
    if (renderFunction != null /* && renderFunction.getRenderedObjectType().isAssignableFrom(this.getClass()))*/ ) {
      this.renderFunction = (RenderFunction<T>) renderFunction;
    } else {
      throw new IllegalArgumentException("Render function is not compatible with the type of game object");
    }
  }
}
public interface BoidBehavior {

  PVector calculateMovement(Boid boid, ArrayList<Boid> neighbors);
}

public class FlockBehavior implements BoidBehavior {
  public PVector calculateMovement(Boid boid, ArrayList<Boid> neighbors) {

    if (neighbors.size() == 0) return new PVector(0, 0);

    // Calculate movement direction based on all flocking rules:

    PVector separationForce = new PVector(0, 0);
    PVector cohesionForce = new PVector(0, 0);
    PVector alignmentForce = new PVector(0, 0);

    // Force Scalars
    float separationScale = 80f;
    float cohesionScale = 0.5f;
    float alignmentScale = 3f;
    
    // Separation min distance percent
    float minSeparationPercent = 0.3f;

    float numNeighbors = (neighbors.size()==0)? 1f : (float)neighbors.size();

    float minSeparationDistance = minSeparationPercent * boid.getPerceptionRadius();
    float separationNeighbors = 0;
    // Calculate Separation Force:
    for (Boid neighbor : neighbors) {

      PVector difference = PVector.sub(boid.getPosition(), neighbor.getPosition());
      float distance = difference.mag();

      if (distance < minSeparationDistance) {
        difference.normalize();
        //println(distance);
        //difference.div(distance*distance);
        separationForce.add(difference);
        separationNeighbors += 1;
      }
    }
    if (separationNeighbors > 0) separationForce.div(separationNeighbors); // This represents the AVERAGE push

    // Calculate Cohesion Force:
    PVector averagePostion = new PVector(0, 0);
    for (Boid neighbor : neighbors) {
      averagePostion.add(neighbor.getPosition());
    }
    averagePostion.div(numNeighbors);
    cohesionForce = PVector.sub(averagePostion, boid.getPosition());


    // Calculate Alignment Force:
    PVector averageVelocity = new PVector(0, 0);
    for (Boid neighbor : neighbors) {
      averageVelocity.add(neighbor.getVelocity());
    }
    averageVelocity.div(numNeighbors);
    alignmentForce = PVector.sub(averageVelocity, boid.getVelocity());

    // Scale all forces by the corresponding multiplier
    separationForce.mult(separationScale);
    cohesionForce.mult(cohesionScale);
    alignmentForce.mult(alignmentScale);

    // Calculate and add net force:
    PVector netForce = new PVector(0, 0);
    netForce.add(separationForce);
    netForce.add(cohesionForce);
    netForce.add(alignmentForce);
    
    //netForce.normalize().div(60);

    return netForce;
  }
}



// TODO: Needs to be completed
public class SeparationBehavior implements BoidBehavior {
  public PVector calculateMovement(Boid boid, ArrayList<Boid> neighbors) {
    if (neighbors.isEmpty()) return new PVector();

    PVector separationVector = new PVector();
    float protectedRange = 100; // Range of the radius
    float avoidFactor = 2f; //avoidance intensity

    for (Boid neighbor : neighbors) {
      float distance = PVector.dist(boid.position, neighbor.position);

      // Check if the neighbor is within the protected range
      if (distance < protectedRange && distance > 0) {
        PVector difference = PVector.sub(boid.position, neighbor.position);
        separationVector.add(difference);
      }
    }

    // Apply the avoid factor to scale the separation force if needed
    separationVector.mult(avoidFactor);

    return separationVector;
  }
}

// TODO: Needs to be completed
public class AlignmentBehavior implements BoidBehavior {
  public PVector calculateMovement(Boid boid, ArrayList<Boid> neighbors) {
    if (neighbors.size() == 0) return new PVector();

    // Calculate movement direction based on alignment rule
    PVector avg_Velocity = new PVector(0, 0);
    for (Boid b : neighbors) {
      avg_Velocity.add(b.velocity);
    }

    avg_Velocity.div(neighbors.size());
    return avg_Velocity.sub(boid.velocity);
  }
}

// TODO: Needs to be completed
public class CohesionBehavior implements BoidBehavior {
  public PVector calculateMovement(Boid boid, ArrayList<Boid> neighbors) {
    // Calculate movement direction based on cohesion rule
    if (neighbors.size() == 0) return new PVector();

    // Calculate movement direction based on alignment rule
    PVector avg_Position = new PVector(0, 0);
    for (Boid b : neighbors) {
      avg_Position.add(b.position);
    }

    avg_Position.div(neighbors.size());
    return avg_Position.sub(boid.position);
  }
}

// Circle behavior class
class CircleBehavior implements BoidBehavior {
  private float angularSpeed;

  CircleBehavior(float angularSpeed) {
    this.angularSpeed = angularSpeed;
  }

  public PVector calculateMovement(Boid boid, ArrayList<Boid> neighbors) {
    // Calculate movement to make the boid turn in a circle
    PVector rotation = boid.velocity.copy().rotate(HALF_PI); // Perpendicular to velocity
    rotation.normalize().mult(angularSpeed); // Set magnitude
    return rotation;
  }
}
// Interface for renderable game objects
interface Renderable {
  void render();
  void setRenderFunction(RenderFunction<?> renderFunction);
}

// Function interface for rendering game objects
interface RenderFunction<T> {
    void render(T gameObject);
}


class SimpleBoid implements RenderFunction<Boid> {
  public void render(Boid boid) {
    
    PVector pos = boid.position;
    PVector vel = boid.velocity.copy();
    PVector velDir = vel.copy().normalize();
    
    // TODO, this is just for testing, will eventually move these vars to better encapsulate 
    int primaryColor = color(000000);
    float size = 15f;
    
    stroke(0);
    strokeWeight(1.5f);
    fill(primaryColor);
    circle(pos.x, pos.y, size);
    
    fill(255);
    circle(pos.x+(3*velDir.x), pos.y+(3*velDir.y), 7f);

    // temp direction showing
    stroke(color(255, 0, 0));
    line(pos.x, pos.y, pos.x + vel.x * 10f, pos.y + vel.y * 10f);
  }
}

class SimpleBoidDebug implements RenderFunction<Boid> {
  public void render(Boid boid) {
    
    PVector pos = boid.position;
    PVector vel = boid.velocity.copy();
    PVector velDir = vel.copy().normalize();
    
    // TODO, this is just for testing, will eventually move these vars to better encapsulate 
    int primaryColor = color(000000);
    float size = 15f;
    
    stroke(0);
    strokeWeight(1.5f);
    fill(primaryColor);
    circle(pos.x, pos.y, size);
    
    fill(255);
    circle(pos.x+(3*velDir.x), pos.y+(3*velDir.y), 7f);
    
    push();
    noStroke();
    fill(153, 255, 153, 20);
    circle(pos.x, pos.y, 2* boid.getPerceptionRadius());
    
    pop();
    
    
    // temp direction showing
    stroke(color(255, 0, 0));
    line(pos.x, pos.y, pos.x + vel.x * 10f, pos.y + vel.y * 10f);
  }
}


// Singleton Settings:

public class Settings {
  
  //public static 
  
}


  public void settings() { size(1000, 800); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "ProcessingMockup" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
