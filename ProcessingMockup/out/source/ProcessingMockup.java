/* autogenerated by Processing revision 1293 on 2024-04-29 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.Map;
import java.util.ArrayList;
import java.util.List;
import java.util.HashMap;
import java.util.Map;
import java.util.HashMap;
import java.util.Map;
import java.util.Map;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.HashSet;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class ProcessingMockup extends PApplet {

// We can use an observer pattern for a renderer that updates the screen on a timer or something
// All rendering objects 'listen' to the game clock

// Singleton for settings? Such as boid radius, etc. this is a good sub for a lut
// default settings like default boid color, etc and then just choie of boid color on top of that like user defined but can reset to normal

EventManager eventManager; // this should eventually be created in the world and be dependency injected all the way down as needed, specifically to system entity managers

EntityManager entityManager;
SystemManager systemManager;

float lastFrameTime;

public void setup() {

  /* size commented out by preprocessor */;

  // Setup Main Systems (TODO make this encapsulated in a world object or something) (This would hold the last frame time and stuff.
  eventManager = new EventManager();
  systemManager = new SystemManager(eventManager);
  entityManager = new EntityManager(eventManager);

  // The system manager can be refactored with a factory / builder if desired, minimal priority
  // TODO refactor system manager with a priority queue
  // TODO add the background as a game object
  // TODO refactor render system to draw by layers

  // Initializing the BoidSystem with specific behavioral metrics
  systemManager.addSystem(new BoidSystem(
      110f,              // basePerceptionRadius
      4000f,             // separationScale
      1.0f,              // cohesionScale
      1.1f,              // alignmentScale
      0.30f,             // minSeparationPercent
      90.0f,              // minVelocity
      25f, 25f          // Perception Random Adjustment Range (more randomness)
  ));

  systemManager.addSystem(new BindCanvasWithForce(450f, 50f));
  systemManager.addSystem(new BindCanvasWithTeleport());
  systemManager.addSystem(new PhysicsSystem());
  systemManager.addSystem(new RenderSystem());

  println("Setup()" + " [" + width + ", " + height + "] - Complete");
  
  lastFrameTime = millis() / 1000f;
}


public void draw() {

  // Calculate and update delta time
  float currentTime = millis() / 1000f;
  float deltaTime = currentTime - lastFrameTime;
  lastFrameTime = currentTime;
  
  // Update all systems
  systemManager.updateAll(deltaTime);
}
public void mousePressed() {
  if (mouseButton == LEFT) buildBoidClanRed();
  if (mouseButton == RIGHT) buildBoidClanBlue();
  if (mouseButton == CENTER) buildBoidClanGreen();
}

public void mouseDragged() {
  if (mouseButton == LEFT) buildBoidClanRed();
  if (mouseButton == RIGHT) buildBoidClanBlue();
  if (mouseButton == CENTER) buildBoidClanGreen();
}

public void buildBoid() {
  entityManager.buildEntity("boid", "bindcanvaswithforce")
    .with(new Transform(mouseX, mouseY))
    .with(new Renderer(new BoidTriangle()))
    .with(new RigidBody())
    //.with(new ColorComponent(color(random(255),random(255),random(255)), color(random(255),random(255),random(255),0)))
    .with(new ColorComponent(color(0,255,0), color(0)))
    .create();
}

public void buildBoidClanRed() {

  int primary = color(255,0,0);
  int stroke = color(0);
  
  entityManager.buildEntity("boid", "bindcanvaswithforce")
    .with(new Transform(mouseX, mouseY))
    .with(new Renderer(new BoidTriangle()))
    .with(new RigidBody())
    .with(new ClanComponent("Red Clan", primary))
    .with(new ColorComponent(primary, stroke))
    .create();

}

public void buildBoidClanBlue() {

  int primary = color(0,0,255);
  int stroke = color(0);
  
  entityManager.buildEntity("boid", "bindcanvaswithforce")
    .with(new Transform(mouseX, mouseY))
    .with(new Renderer(new BoidTriangle()))
    .with(new RigidBody())
    .with(new ClanComponent("Blue Clan", primary))
    .with(new ColorComponent(primary, stroke))
    .create();

}

public void buildBoidClanGreen() {

  int primary = color(30,150,30);
  int stroke = color(0);
  
  entityManager.buildEntity("boid", "bindcanvaswithforce")
    .with(new Transform(mouseX, mouseY))
    .with(new Renderer(new BoidTriangle()))
    .with(new RigidBody())
    .with(new ClanComponent("Green Clan", primary))
    .with(new ColorComponent(primary, stroke))
    .create();

}
public class BoidSystem extends System {

  private Map<Integer, Transform> transforms = new HashMap<>();
  private Map<Integer, RigidBody> rigidBodies = new HashMap<>();
  private Map<Integer, ClanComponent> clans = new HashMap<>();

  // Data Members / Setting Variables
  private float perceptionRadius = 110f;
  private float basePerceptionRadius = 110f;
  private float minSeparationPercent = 0.25f;
  private float minVelocity = 0f; // ensures min velocity, set manually rn, but this can change easily

  private float minPerceptionAdjustment = 0;
  private float maxPerceptionAdjustment = 0;

  private float minSeparationDistance = 0.01f;

  // Force Scalars
  private float separationScale = 5000f;
  private float cohesionScale = 1f;
  private float alignmentScale = 1f;

  // ---------- Constructors ---------- //
  public BoidSystem() {
  }

  public BoidSystem(float perceptionRadius, float separationScale, float cohesionScale, float alignmentScale, float minSeparationPercent, float minVelocity, float minPerceptionAdjustment, float maxPerceptionAdjustment) {
    this.basePerceptionRadius = perceptionRadius;
    this.perceptionRadius = perceptionRadius;
    float adjustment = random(-minPerceptionAdjustment, maxPerceptionAdjustment);
    this.perceptionRadius += adjustment;
    
    this.separationScale = separationScale;
    this.cohesionScale = cohesionScale;
    this.alignmentScale = alignmentScale;
    this.minSeparationPercent = minSeparationPercent;
    this.minVelocity = minVelocity;
  }

  public BoidSystem(float perceptionRadius, float separationScale, float cohesionScale, float alignmentScale, float minSeparationPercent, float minVelocity) {
    this(perceptionRadius, separationScale, cohesionScale, alignmentScale, minSeparationPercent, minVelocity, 0, 0);
  }

  @Override
  protected boolean matchesSystemCriteria(ComponentEvent event) {
    boolean ifMatches = event.entity.hasTag("boid"); //event.isComponentType(RigidBody.class) && 
    return ifMatches;
  }

  @Override
  protected void onComponentAdded(Entity entity, Component component) {
    Integer ID = entity.getID();

    // TODO Update the map.component system to work with the tabular setup and only store each map once and automatically

    if (component instanceof Transform) {
        transforms.put(ID, (Transform) component); // todo change this once transform becomes attached by default to the entity
    } else if (component instanceof RigidBody) {
        rigidBodies.put(ID, (RigidBody) component);
    } else if (component instanceof ClanComponent) {
        clans.put(ID, (ClanComponent) component);
    }
    
  }

  @Override
    protected void onComponentRemoved(Entity entity, Component component) {
    // Implementation for removing a component from the rendering system // todo for ben
  }

  @Override
    public void update(float deltaTime) {
    if (transforms.size() == 0) return;

    // Loop through each boid
    for (Integer id : transforms.keySet()) {

      // Boid Properties
      Transform transform = this.transforms.get(id);
      PVector position = transform.getPosition();
      RigidBody rigidBody = this.rigidBodies.get(id);
      PVector velocity = rigidBody.getVelocity();
      ClanComponent clan = this.clans.get(id);

      PVector separationForce = new PVector(0, 0);
      PVector cohesionForce = new PVector(0, 0);
      PVector alignmentForce = new PVector(0, 0);

      float numNeighbors = 0;  // Count of neighbors
      PVector averagePosition = new PVector(0, 0);
      PVector averageVelocity = new PVector(0, 0);

      // Loop through all neighbors to calculate relative forces
      for (Integer neighborID : transforms.keySet()) {

        // Neighbor Properties
        Transform neighborTransform = this.transforms.get(neighborID);
        PVector neighborPosition = neighborTransform.getPosition();
        RigidBody neighborRigidBody = this.rigidBodies.get(neighborID);
        PVector neighborVelocity = neighborRigidBody.getVelocity();
        ClanComponent neighborClan = this.clans.get(neighborID);

        if (id == neighborID) continue; // Skip the current boid itself

        PVector difference = PVector.sub(position, neighborPosition);
        float distance = PVector.dist(position, neighborPosition);

        if (distance > perceptionRadius) continue; // Skip non neighbors

        // CLAN BEHAVIOR:
        if ((clan != null) && (neighborClan != null)) {
          // If different clan, do specific behavior
          if (clan.name != neighborClan.name) {
            // C+P separation force, further distance
            if (distance < (/*minSeparationPercent * */ basePerceptionRadius)) {
              difference.normalize().div(distance);  // Stronger repulsion at closer distances
              separationForce.add(difference);
            }
            continue; // After different clan behavior, go next->
          }
        }

        // Check if the current boid is within perception radius
        numNeighbors++;

        // Separation
        if (distance < (minSeparationPercent * basePerceptionRadius)) {

          if(distance < minSeparationDistance) distance = minSeparationDistance;
          
          difference.normalize().div(distance);  // Stronger repulsion at closer distances
          separationForce.add(difference);
        }

        // Cohesion
        averagePosition.add(neighborPosition);

        // Alignment
        averageVelocity.add(neighborVelocity);
      }

      if (numNeighbors > 0) {
        averagePosition.div(numNeighbors);
        cohesionForce = PVector.sub(averagePosition, position);

        averageVelocity.div(numNeighbors);
        alignmentForce = PVector.sub(averageVelocity, velocity);
      }

      // Scale all forces
      separationForce.mult(separationScale);
      cohesionForce.mult(cohesionScale);
      alignmentForce.mult(alignmentScale);

      // Apply all forces
      rigidBody.applyForce(separationForce);
      rigidBody.applyForce(cohesionForce);
      rigidBody.applyForce(alignmentForce);

      // Update velocity after applying force
      velocity = rigidBody.getVelocity();

      // Min velocity logic
      if ((velocity.mag() < minVelocity) && (velocity.mag() > 0)) {
        rigidBody.setVelocity(velocity.setMag(minVelocity));
      }
    }
  }
}
//// Interface for collision behavior
//interface CollisionBehavior {
//    boolean collidesWith(GameObject other);
//}
public interface Component {

  /* Description:
   Components are added to entities to compose behavior from small parts.
   */

  /* Method to initialize the component:
   Performs initialization tasks when the component is attached to an entity
   */
  default void initialize() {
  }

  /* Method to clean up the component:
   Performs cleanup tasks when the component is removed from an entity.
   This include removing observers, preventing memory leaks, etc.
   */
  default void cleanup() {
  }
}

//// Tags provide a unique identification system of entity types. This is to distinguish two entities that are different but share the same set of components
//public class Tag implements Component {
//  private String tag;

//  public Tag() {
//    this.setTag("default");
//  }

//  public Tag(String tag) {
//    this.setTag(tag);
//  }

//  public String getTag() {
//    return tag;
//  }

//  public void setTag(String tag) {
//    this.tag = tag.toLowerCase();
//  }
//}

public class Transform implements Component {

  protected PVector position;
  protected PVector direction;
  protected PVector scale;

  // Position
  public PVector getPosition() {
    return position.copy();
  }
  public PVector getDirection() {
    return direction.copy();
  }

  public PVector getScale() {
    return scale.copy();
  }

  public Transform() {
    this.position = new PVector(0, 0);
    this.direction = new PVector(0, 1);
    this.scale = new PVector(1, 1);
  }

  public Transform(float initialX, float initialY) {
    this.position = new PVector(initialX, initialY);
    this.direction = new PVector(0, 1);
    this.scale = new PVector(1, 1);
  }

  public Transform(PVector initialPosition, PVector initialDirection) {
    this.position = initialPosition.copy();
    this.direction = initialDirection.copy();
    this.scale = new PVector(1, 1);
  }

  public void setPosition(PVector position) {
    this.position = position;
  }

  public void setDirection(PVector direction) {
    this.direction = direction.normalize(); // Ensure the vector is normalized
  }

  public void setScale(PVector scale) {
    this.scale = scale;
  }

  public void moveBy(PVector moveAmount) {
    setPosition(PVector.add(this.position, moveAmount));
  }

  public void rotateBy(float angle) {
    direction.rotate(angle);
  }
  public void rotateTo(PVector target) {
    direction.set(target.normalize());
  }

  public float distanceTo(Transform other) {
    return this.position.dist(other.position);
  }
}


/* Component interface for rendering behavior:
 TODO: Make this more portable to other non processing systems, aka an abstract class and an extended processing specific renderer
 */
public class Renderer implements Component {

  private RenderFunction renderFunction;

  public Renderer(RenderFunction renderFunction) {
    this.renderFunction = renderFunction;
  }

  // Make set render function / get render function / remove render function
  
  
  public void render(PGraphics renderContext, Transform transform) {
    render(renderContext, transform, null);
  }

  public void render(PGraphics renderContext, Transform transform, ColorComponent colorComponent) {
    //println("In render component.render");
    if (renderFunction != null) {
      if (colorComponent == null) {
         renderFunction.render(renderContext, transform);
      } else {
        renderFunction.render(renderContext, transform, colorComponent);
      }
     
    }
  }
}

public class ColorComponent implements Component {
  public int primary = color(0, 0, 0, 0);
  public int secondary = color(0, 0, 0, 0);
  public int terinary = color(0, 0, 0, 0);

  public int randomColor = color(random(255), random(255), random(255));

  public ColorComponent(int p, int s, int t) {
    this.primary = p;
    this.secondary = p;
    this.terinary = t;
  }
  public ColorComponent(int p, int s) {
    this.primary = p;
    this.secondary = s;
  }
  public ColorComponent(int p) {
    this.primary = p;
  }

  public int randomColorNext() {
    randomColor = color(random(255), random(255), random(255));
    return randomColor;
  }
  public ColorComponent() {
  };
}

//also is my ecs system even working as an ecs system is supposed to work? I have my systems basically having the whole list of entities- why did i bother with all of these event listeners and abstraction and decoupling if the systems were going to just read from the same list of entities just broken up components from the start? What am I missing here- is it my understanding or my code? I think I did something fundamentally off. I know entities are supposed to have a reference to a bunch of components stored together in memory... do i have to abstract away each of these arrays and then use pointers and some sort of map filtering when iterating


public class RigidBody implements Component {

  private PVector velocity = new PVector(0, 0);
  private PVector acceleration = new PVector(0, 0);
  private float mass = 1;

  public boolean isStatic = false;

  public RigidBody() {
    // Empty default constructor
    // TODO make a few more constuctors for init velocity and mass, no init acceleration
    // TODO make a few more changes to also allow for creation of static bodies.
  }

  public void applyForce(PVector force) {

    // Return early if needed
    if (isStatic) return;
    if (force.x == 0 && force.y == 0) return; // no work for 3d

    PVector forceAcc = PVector.div(force, mass);
    acceleration.add(forceAcc);
  }

  public void update(float deltaTime) {

    if (isStatic) return;
    velocity.add(PVector.mult(acceleration, deltaTime));
    acceleration.mult(0); // Clear acc after each update, i guess unless it is gravity but we aint doing that, there is a better way to do this i think
  }

  public PVector getVelocity() {
    return this.velocity.copy();
  }

  public void setVelocity(PVector velocity) {
    this.velocity = velocity;
  }
}

public class ClanComponent implements Component {
    public String name;
    public int clanColor;

    public ClanComponent(String name, int clanColor) {
        this.name = name;
        this.clanColor = clanColor;
    }
}


public class Entity {

  /* Description:
   Entity is an object that can have components. Components are handled and define
   all of the behavior we want. The big picture of this approach is to facor composition
   over inheritance to reduce dependencies. For example a Boid gameObject is a gameObject
   that would have components that give its behavior, rendering, collisions, etc.
   Research ECS pattern for details.
   */

  // ---------- Entity Member Variables ---------- //

  /* ID System:
   The unique ID of is made and handled in the manager
   */
  private int id;

  /* Components:
   We store the gameObject components as a map, and use componentType as a LUT.
   This solves the problem of handling duplicate components (no duplicates allowed)
   and lets us find a given component in O(1) time!
   */
  private Map<Class<? extends Component>, Component> components = new HashMap<>();

  private Set<String> tags = new HashSet<>(); // Multiple tags


  // ---------- Constructor ---------- //
  public Entity(int id) {
    this.id = id;
  }
  // TODO upgrade tag system to make it so we can shove it in on constructor
  //public Entity(int id) {
  //  this.id = id;
  //}


  // ---------- Component Handling ---------- //

  /* DESCRIPTION:
   Components are attached to the game entity. For instance if an entity is renderable, we attach a
   'renderable' compoent to the object. This allows us to define the scope and behavior of each entity on instantiation.
   The components attached to a given entity are typically done in the entityManager.
   Components are stored in a map for O(1) look up time.
   */

  // addComponent (with instance of component)
  public <T extends Component> void addComponent(T component) {
    components.put(component.getClass(), component);
    component.initialize();
  }

  // removeComponent (by component class)
  public <T extends Component> void removeComponent(Class<T> componentClass) {
    Component component = components.remove(componentClass);
    component.cleanup();
  }

  // getComponent (by component class)
  public <T extends Component> T getComponent(Class<T> componentClass) {
    return componentClass.cast(components.get(componentClass));
  }

  // hasComponent (of component class) T/F
  public <T extends Component> boolean hasComponent(Class<T> componentClass) {
    return components.containsKey(componentClass);
  }

  public List<Component> getComponents() {
    return (List)components.values();
  }

  // ---------- Tag Handling ---------- //
  public void addTag(String tag) {
    tags.add(tag.toUpperCase());
  }
  public void removeTag(String tag) {
    tags.remove(tag);
  }

  public boolean hasTag(String tag) {
    return tags.contains(tag.toUpperCase());
  }

  public Set<String> getTags() {
    return new HashSet<>(tags); // Return a copy to maintain encapsulation
  }

  public void cleanup() {
    for (Component component : components.values()) {
      removeComponent(component.getClass());
    }
  }

  public int getID() {
    return this.id;
  }
}



public class EntityBuilder {
  private final EntityManager entityManager;
  private final Entity entity;
  private final List<Component> componentsToNotify;  // List to store components temporarily


  // When builder is constructed in the context of the entity manager class, we create new entity with the genrated id
  public EntityBuilder(EntityManager entityManager, int entityId, List<String> tags) {
    this.entityManager = entityManager;
    this.entity = new Entity(entityId);
    this.componentsToNotify = new ArrayList<>();
    
    // TODO SCUFFED
    // Add tags - TODO this can be made way better
    if (tags != null) {
      for (String tag : tags) {
        entity.addTag(tag);
      }
    }

    //// Transform and Tag components are being added by default
    //Transform defaultTransform = new Transform();  // Example: create a default transform
    //Tag defaultTag = new Tag("default");  // Example: create a default tag
    //this.componentsToNotify.add(defaultTransform);
    //this.componentsToNotify.add(defaultTag);

    // TODO add transform and tag components by default since all entities should have a default tag and a transform.
    print("EntityBuilder: ID " + entity.getID());
  }

  // Add methods to configure the entity as needed
  public EntityBuilder with(Component component) {
    print();
    // TODO make this so all of the events are done after create is called in a buffer IMPORTANT
    this.entity.addComponent(component);
    this.componentsToNotify.add(component);
    return this;
  }

  // Method to build and return the created entity
  // printing / logging is handled, it is jank
  public Entity create() {
    
    entityManager.addEntity(entity);

    // Logging logic for prettyness
    print(" | with components (");
    boolean isFirst = true;
    
    for (Component component : componentsToNotify) {
      // Actually important, call events of component added.
      eventManager.notifySubscribers(new ComponentAddedEvent(entity, component));
      
      // Printing logic
      print((isFirst ? "" : ", ") + component.getClass().getSimpleName());
      isFirst = false;
    }
    
    // End printing component logic
    println(") - Created");
    
    return entity;
  }
}
 //<>//


// TODO Explain later, main idea is give entity an id so they can be stored in LUT
// We have serveral things to help run the game more like create destroy and modify components of a game object



public class EntityManager {
  private int nextEntityId = 0;
  private Map<Integer, Entity> entities = new HashMap<>();

  private EventManager eventManager;

  public EntityManager(EventManager eventManager) {
    this.eventManager = eventManager;
  }


  // ---------- Entity Creation ---------- //

  // Create a new entity with an automatically generated ID
  public EntityBuilder buildEntity() {
    return new EntityBuilder(this, nextEntityId++, null);
    
  }
  public EntityBuilder buildEntity(String... tags) {
    List<String> tagList = new ArrayList<>();
    for (String tag : tags) {
      tagList.add(tag);
    }
    return new EntityBuilder(this, nextEntityId++, tagList);
  }

  // Method to add the created entity to the entity manager
  public void addEntity(Entity entity) {
    entities.put(entity.getID(), entity);
  }

  // Delete an entity by removing it from the map
  public void deleteEntity(int entityId) {
    Entity entity = entities.remove(entityId);
    if (entity == null) return;

    for (Component component : entity.getComponents()) {
      // TODO remove component and unsubscibe them
    }

    entity.cleanup();
  }

  // ---------- Entity Management ---------- //


  // Attach a component to an entity
  // Note absense of checks for duplicates. this should be okay bc of datastructures using, but dont attach component more than once bro.
  public <T extends Component> void attachComponent(int entityId, T component) {
    println("Attach component");

    Entity entity = entities.get(entityId);
    if (entity == null) return;

    // can be thought of set component, can explore this later to make it clearer and avoid resetting if that is a concern
    entity.addComponent(component);

    println("Notifying Subscribers of Component Added");
    eventManager.notifySubscribers(new ComponentAddedEvent(entity, component));
  }



  // Remove a component from an entity
  public <T extends Component> void removeComponent(int entityId, Class<T> componentClass) {

    Entity entity = entities.get(entityId);
    if (entity == null) return;

    Component component = entity.getComponent(componentClass);
    eventManager.notifySubscribers(new ComponentRemovedEvent(entity, component));
    entity.removeComponent(componentClass);
  }

  // Get a component attached to an entity // TODO might need to make some error catching
  public <T extends Component> T getComponent(int entityId, Class<T> componentClass) {

    Entity entity = entities.get(entityId);

    return (entity != null)? entity.getComponent(componentClass) : null;
  }

  public Entity getEntityByID(int entityID) {
    // Check map for given ID
    Entity entity = entities.get(entityID);
    // Handle the case where the specified ID does not exist // MAYBE JUST RETURN NULL???? TODO FOR FUTURE DECISION
    if (entity == null) throw new IllegalArgumentException("No entity found with ID: " + entityID);
    return entity;
  }

  // this is for testing should not be used, breaks encapsulation
  public Map<Integer, Entity> TestingGetEntities() {
    return this.entities;
  }
}




public interface Event {
  // Define methods common to all events, havent decided on this yet
}

//// Types of events:
//public class CollisionEvent implements Event {
//    // Add properties specific to collision events
//}

//public class InteractionEvent implements Event {
//    // Add properties specific to interaction events
//}\


public class ComponentEvent implements Event {
  private Entity entity;                                // The entity from which the event originates
  private Component component;                          // The component involved in the event
  private Set<String> associatedTags;                   // A set of tags associated with the entity
  private Class<? extends Component> componentClass;

  public ComponentEvent(Entity entity, Component component) {
    this.entity = entity;
    this.component = component;
    this.componentClass = component.getClass();
    this.associatedTags = entity.getTags();
  }

  public Entity getEntity() {
    return entity;
  }

  public Component getComponent() {
    return component;
  }

  public Class<? extends Component> getComponentClass() {
    return this.componentClass;
  }

  public Set<String> getTags() {
    return associatedTags;
  }

  public boolean isComponentType(Class<? extends Component> type) {
    return type.isInstance(component);
  }

  public boolean hasTags(String... requiredTags) {
    Set<String> entityTags = entity.getTags();
    return Arrays.stream(requiredTags).allMatch(entityTags::contains);
  }
}

public class ComponentAddedEvent extends ComponentEvent {
  public ComponentAddedEvent(Entity entity, Component component) {
    super(entity, component);
  }
}

public class ComponentRemovedEvent extends ComponentEvent {
  public ComponentRemovedEvent(Entity entity, Component component) {
    super(entity, component);
  }
}






public interface EventListener {
  void handleEvent(Event event);
}

public class EventManager {
  private Map<Class<? extends Event>, List<EventListener>> subscribers = new HashMap<>();

  public void subscribe(Class<? extends Event> eventType, EventListener listener) {
    subscribers.computeIfAbsent(eventType, k -> new ArrayList<>()).add(listener);
  }

  public void unsubscribe(Class<? extends Event> eventType, EventListener listener) {
    List<EventListener> listeners = subscribers.get(eventType);

    if (listeners == null) return;

    listeners.remove(listener);
    
    if (listeners.isEmpty()) subscribers.remove(eventType);
  }

  public void notifySubscribers(Event event) {
    List<EventListener> listeners = subscribers.get(event.getClass());

    if (listeners == null) return;

    for (EventListener listener : listeners) {
      listener.handleEvent(event);
    }
  }
}
//public interface BoidBehavior {

//  PVector calculateMovement(Boid boid, ArrayList<Boid> neighbors);
//}

//public class FlockBehavior implements BoidBehavior {
//  public PVector calculateMovement(Boid boid, ArrayList<Boid> neighbors) {
//    // Calculate movement direction based on all flocking rules:
    
//    PVector separationForce = new PVector(0,0);
//    PVector cohesionForce = new PVector(0,0);
//    PVector alignmentForce = new PVector(0,0);
    
//    // Calculate Separation Force:
//    // separationForce = new PVector(1,0);
    
//    // Calculate Cohesion Force:


//    // Calculate Alignment Force:



//    // Calculate and add net force:
//    PVector netForce = separationForce.add(cohesionForce).add(alignmentForce);
//    return netForce;
//  }
//}


//public class SeparationBehavior implements BoidBehavior {
//  public PVector calculateMovement(Boid boid, ArrayList<Boid> neighbors) {
//    // Calculate movement direction based on separation rule
//    return new PVector();
//  }
//}

//public class AlignmentBehavior implements BoidBehavior {
//  public PVector calculateMovement(Boid boid, ArrayList<Boid> neighbors) {
//    // Calculate movement direction based on alignment rule
//    return new PVector();
//  }
//}

//public class CohesionBehavior implements BoidBehavior {
//  public PVector calculateMovement(Boid boid, ArrayList<Boid> neighbors) {
//    // Calculate movement direction based on cohesion rule
//    return new PVector();
//  }
//}

//// Circle behavior class
//class CircleBehavior implements BoidBehavior {
//  private float angularSpeed;

//  CircleBehavior(float angularSpeed) {
//    this.angularSpeed = angularSpeed;
//  }

//  public PVector calculateMovement(Boid boid, ArrayList<Boid> neighbors) {
//    // Calculate movement to make the boid turn in a circle
//    PVector rotation = boid.velocity.copy().rotate(HALF_PI); // Perpendicular to velocity
//    rotation.normalize().mult(angularSpeed); // Set magnitude
//    return rotation;
//  }
//}



// TODO REFACTOR SO IT EXISTS AS A SAVED RENDER
public interface RenderFunction {
  void render(PGraphics renderContext, Transform transform);
  default void render(PGraphics renderContext, Transform transform, ColorComponent colorComponent) {
  }
}

public class CircleRenderFunction implements RenderFunction {
  public void render(PGraphics renderContext, Transform transform) {
    //println("In CircleRenderFunction");

    PVector pos = transform.getPosition();
    PVector dir = transform.getDirection();
    PVector scale = transform.getScale();

    //println("In CircleRenderFunction PASSED ASSIGNMENT");


    int primaryColor = color(180, 30, 70);

    renderContext.push();
    //println("In CircleRenderFunction renderContext.push();");

    renderContext.fill(primaryColor);
    renderContext.circle(pos.x, pos.y, 15f);
    renderContext.pop();
  }
  public void render(PGraphics renderContext, Transform transform, ColorComponent colorComponent) {
    PVector pos = transform.getPosition();
    PVector dir = transform.getDirection();
    PVector scale = transform.getScale();

    //println("In CircleRenderFunction PASSED ASSIGNMENT");

    renderContext.push();
    //println("In CircleRenderFunction renderContext.push();");

    renderContext.fill(colorComponent.primary);

    if (alpha(colorComponent.secondary) == 0) {
      renderContext.noStroke();
    } else {
      renderContext.stroke(colorComponent.secondary);
    }

    renderContext.circle(pos.x, pos.y, 15f);
    renderContext.pop();
  }
}

public class BoidTriangle implements RenderFunction {
  
  PVector lookDirection = new PVector(random(-.4f, .4f), random(-.2f, .5f));
  float lookScale = random(.3f,1);
  float lookSpeed = 0.1f;

  // Default colora values (if no color component passed in / colorcomponent == null)
  int primaryColor = color(255);
  int secondaryColor = color(0);
  
  public void render(PGraphics renderContext, Transform transform, ColorComponent colorComponent) {
    PVector pos = transform.getPosition();
    PVector dir = transform.getDirection();
    PVector scale = transform.getScale();
    
    if (colorComponent != null) {
      this.primaryColor = colorComponent.primary;
      this.secondaryColor = colorComponent.secondary;
    }

    dir.normalize();

    renderContext.push(); // Save the current state of the renderContext

    // Move the coordinate system to the position where the triangle should be drawn
    renderContext.translate(pos.x, pos.y);

    //float angle = PVector.angleBetween(new PVector(0, 1), dir); // Angle with respect to the positive y-axis
    float angle = atan2(dir.y, dir.x) - HALF_PI;
    //if (dir.x < 0) angle = -angle; // Correct the rotation direction based on the x component

    renderContext.rotate(angle);

    // Define the base width and height of the triangle based on scale
    float baseW = 8 * scale.x;
    float baseH = baseW * 2 * scale.y;

    renderContext.fill(primaryColor);
    renderContext.noStroke();

    // Draw the triangle
    renderContext.triangle(
      -baseW / 2, -baseH / 2, // Bottom left vertex
      baseW / 2, -baseH / 2, // Bottom right vertex
      0, baseH / 2                // Top vertex (apex)
      );

    float eyeOuterDiameter = .8f * baseW;
    float eyeInnerDiameter = eyeOuterDiameter * 0.65f;
    float maxLookAmount = eyeOuterDiameter - eyeInnerDiameter;
    float lookAmount = lookScale * maxLookAmount;
    PVector lookVector = PVector.mult(lookDirection, lookAmount);

    float eyeBridgeWidth = eyeOuterDiameter * 0.7f;
    float eyeVerticalOffset = baseH * -0.2f;

    // Base Eye
    renderContext.translate(0, eyeVerticalOffset);
    renderContext.translate(eyeBridgeWidth/2f, 0);
    renderContext.fill(255);
    renderContext.circle(0, 0, eyeOuterDiameter);

    renderContext.translate(-eyeBridgeWidth, 0);
    renderContext.fill(255);
    renderContext.circle(0, 0, eyeOuterDiameter);

    // Pupils
    renderContext.translate(lookVector.x/2, lookVector.y/2);
    renderContext.translate(eyeBridgeWidth, 0);
    renderContext.fill(0);
    renderContext.circle(0, 0, eyeInnerDiameter);

    renderContext.translate(-eyeBridgeWidth, 0);
    renderContext.fill(0);
    renderContext.circle(0, 0, eyeInnerDiameter);

    renderContext.pop(); // Restore the original state of the renderContext
  }

  public void render(PGraphics renderContext, Transform transform) {
    ColorComponent colorComponent = null;
    render(renderContext, transform, colorComponent);
  }
}
// Interface for renderable game objects



// ---------- Renderable Component ---------- //
/* Description:
 Describes the render behavior of a gameObject. Attach this component with a corresponding 'RenderFunction'
 to describe the specifics of how to render the object.
 */
 
//interface Renderable extends Component {
//  void render();
//  void setRenderFunction(RenderFunction<?> renderFunction);
//}



//// ---------- Render Function ---------- //
///*
//TODO: Elaborate on dynamic typing and any specifics
//*/

//// Function interface for rendering game objects
//interface RenderFunction<T> {
//  void render(T gameObject);
//}

//class SimpleBoid implements RenderFunction<Boid> {
//  public void render(Boid boid) {

//    PVector pos = boid.position;
//    PVector vel = boid.velocity.copy();
//    PVector velDir = vel.copy().normalize();

//    // TODO, this is just for testing, will eventually move these vars to better encapsulate
//    color primaryColor = color(000000);
//    float size = 15f;

//    stroke(0);
//    strokeWeight(1.5);
//    fill(primaryColor);
//    circle(pos.x, pos.y, size);

//    fill(255);
//    circle(pos.x+(3*velDir.x), pos.y+(3*velDir.y), 7f);

//    // temp direction showing
//    stroke(color(255, 0, 0));
//    line(pos.x, pos.y, pos.x + vel.x * 10f, pos.y + vel.y * 10f);
//  }
//}

//class SimpleBoidDebug implements RenderFunction<Boid> {
//  public void render(Boid boid) {

//    PVector pos = boid.position;
//    PVector vel = boid.velocity.copy();
//    PVector velDir = vel.copy().normalize();

//    // TODO, this is just for testing, will eventually move these vars to better encapsulate
//    color primaryColor = color(000000);
//    float size = 15f;

//    stroke(0);
//    strokeWeight(1.5);
//    fill(primaryColor);
//    circle(pos.x, pos.y, size);

//    fill(255);
//    circle(pos.x+(3*velDir.x), pos.y+(3*velDir.y), 7f);

//    push();
//    noStroke();
//    fill(153, 255, 153, 80);
//    circle(pos.x, pos.y, boid.getPerceptionRadius());

//    pop();


//    // temp direction showing
//    stroke(color(255, 0, 0));
//    line(pos.x, pos.y, pos.x + vel.x * 10f, pos.y + vel.y * 10f);
//  } 
//}



public class SystemManager {
  private List<System> systems = new ArrayList<>();

  private final EventManager eventManager;

  public SystemManager (EventManager eventManager) {
    this.eventManager = eventManager;
  }

  public void addSystem(System system) {
    // Set the event manager with the DI event manager
    // This could be refactored and abstracted further with a factory pattern for marginal readibility and safety benifit
    system.setEventManager(this.eventManager);
    systems.add(system);
  }

  public void removeSystem(System system) {
    systems.remove(system);
  }

  public void updateAll(float deltaTime) {
    //println("Updating all systems...");
    
    for (System system : systems) {
      system.update(deltaTime);
    }
    
  }
}
 //<>//


// TODO refactor systems such that there is only ever one hash map of each component list.
// this should actually be not impossible to do!!!
// Just store the components somewhere and have the event system behave a bit differently to track the references to the relevant component list
// This is a good idea.

public abstract class System {
  protected EventManager eventManager;

  public System() {
    // Note the following todo provides marginal benefit
    // TODO REFACTOR THIS WITH THE FACTORY PATTERN TO MAKE SURE THAT A SYSTEM CANNOT BE CREATED WITHOUT AN EVENT MANAGER
    // This is currently done just with system manager and hoping the user isnt dumb enough to create a system outside of system manager... refactor this
    this.eventManager = null;
  }

  public void setEventManager(EventManager eventManager) {
    this.eventManager = eventManager;

    // Lambdas for event
    this.eventManager.subscribe(ComponentAddedEvent.class, event -> handleComponentAdded(event));
    this.eventManager.subscribe(ComponentRemovedEvent.class, event -> handleComponentRemoved(event));
  }

  private void handleComponentAdded(Event event) {
    if (event instanceof ComponentAddedEvent && matchesSystemCriteria((ComponentEvent) event)) {
      onComponentAdded(((ComponentEvent) event).getEntity(), ((ComponentEvent) event).getComponent());
    }
  }

  private void handleComponentRemoved(Event event) {
    if (event instanceof ComponentRemovedEvent && matchesSystemCriteria((ComponentEvent) event)) {
      onComponentRemoved(((ComponentEvent) event).getEntity(), ((ComponentEvent) event).getComponent());
    }
  }

  // Abstract methods to be implemented by concrete systems
  protected abstract boolean matchesSystemCriteria(ComponentEvent event);
  protected abstract void onComponentAdded(Entity entity, Component component);
  protected abstract void onComponentRemoved(Entity entity, Component component);

  public abstract void update(float deltaTime);
}



// TODO THE RENDERER NEEDS SOME MAJOR REFACTORS TO BE BETTER:
/* need to make it so all rederable entities are prerendered with a pgraphics object
 * separate this by layers, make it so static is done first
 * proper background layers
 * clear or background on a given render context
 * keep the high level render context, but find way to branch and make more dynmically
 */
// Finally im coding and it doesnt have to be perfect
// TODO EXTEND THE LOGIC TO MAKE IT WORK WITH MULTIPLE RENDER CONTEXTS, SEPARATE LAYERS
public class RenderSystem extends System {

  private PGraphics renderContext;

  // ID - Component pairs -> Decouples entity from the system - component calculation
  private Map<Integer, Transform> transforms = new HashMap<>();
  private Map<Integer, Renderer> renderers = new HashMap<>();
  private Map<Integer, ColorComponent> colorComponents = new HashMap<>();

  public RenderSystem() {
    this.renderContext = createGraphics(width, height);
  }

  @Override
    protected boolean matchesSystemCriteria(ComponentEvent event) {
    return event.isComponentType(Renderer.class);
  }

  @Override
    protected void onComponentAdded(Entity entity, Component component) {
    Integer ID = entity.getID();
    // TODO IMPORTANT FIX ANY POTENTAIL BIG ERROR / CRASH HERE
    Transform t = entity.getComponent(Transform.class);
    Renderer r = (Renderer)component;
    ColorComponent c = entity.getComponent(ColorComponent.class);

    // Errors
    if (t==null) return;
    if (r==null) return;
    transforms.put(ID, t);
    renderers.put(ID, r);
    if (c!=null) colorComponents.put(ID, c);

    //println("Adding id:" + ID + " to renderers.");
  }

  @Override
    protected void onComponentRemoved(Entity entity, Component component) {
    // Implementation for removing a component from the rendering system
  }

  // TODO TAKE OUT THE LOGIC FOR INDIVIDUAL RENDER CONTEXT
  @Override
    public void update(float deltaTime) {

    if (renderers.size() == 0) return;

    //println("RenderSystem updating...");

    renderContext.beginDraw();
    renderContext.background(0xFF9CBFED);

    for (Integer id : renderers.keySet()) {

      Renderer renderer = this.renderers.get(id);
      Transform transform = this.transforms.get(id);
      ColorComponent colorComponent = this.colorComponents.get(id);

      if ((renderer == null) || (transform == null)) continue; // TODO ben, make this print a warning / return an exception

      if (colorComponent != null) {
        renderer.render(renderContext, transform, colorComponent);
      } else {
        renderer.render(renderContext, transform);
      }
    }

    renderContext.endDraw();
    image(renderContext, 0, 0);
  }
}

// Finally im coding and it doesnt have to be perfect
public class PhysicsSystem extends System {

  // ID - Component pairs -> Decouples entity from the system - component calculation
  private Map<Integer, Transform> transforms = new HashMap<>();
  private Map<Integer, RigidBody> rigidBodies = new HashMap<>();

  @Override
    protected boolean matchesSystemCriteria(ComponentEvent event) {
    return event.isComponentType(RigidBody.class);
  }

  @Override
    protected void onComponentAdded(Entity entity, Component component) {
    Integer ID = entity.getID();
    transforms.put(ID, entity.getComponent(Transform.class));
    rigidBodies.put(ID, (RigidBody)component);
    // println("Adding id:" + ID + " to rigidbody.");
  }

  @Override
    protected void onComponentRemoved(Entity entity, Component component) {
    // Implementation for removing a component from the rendering system // todo for ben
  }

  @Override
    public void update(float deltaTime) {

    if (transforms.size() == 0) return; // maybe amake a better way to do this check for each system in tyhe system manager TODO mild importance
    //println("Updating physicsSystem");

    for (Integer id : rigidBodies.keySet()) {

      //println("PhysicsSystem updating...");

      RigidBody rigidBody = this.rigidBodies.get(id);
      Transform transform = this.transforms.get(id);

      if ((rigidBody == null) || (transform == null)) continue; // TODO for ben, do the same thing for this one.

      rigidBody.update(deltaTime);

      PVector velocity = rigidBody.getVelocity();
      PVector moveAmount = PVector.mult(velocity, deltaTime);
      transform.rotateTo(velocity);

      transform.moveBy(moveAmount);
    }
  }
}

public class BindCanvasWithForce extends System {

  private Map<Integer, Transform> transforms = new HashMap<>();
  private Map<Integer, RigidBody> rigidBodies = new HashMap<>();

  private float bindForce = 0.5f;
  private float innerBoundary = 50f;

  public BindCanvasWithForce(float bindForce, float innerBoundaryPx) {
    this.bindForce = bindForce;
    this.innerBoundary = innerBoundaryPx;
  }

  @Override
    protected boolean matchesSystemCriteria(ComponentEvent event) {
    return event.isComponentType(RigidBody.class) && event.entity.hasTag("bindcanvaswithforce");
  }

  @Override
    protected void onComponentAdded(Entity entity, Component component) {

    Integer ID = entity.getID();
    transforms.put(ID, entity.getComponent(Transform.class));
    rigidBodies.put(ID, (RigidBody)component);
  }

  @Override
    protected void onComponentRemoved(Entity entity, Component component) {
    // Implementation for removing a component from the rendering system // todo for ben, ben thuis is all u buddy
  }

  @Override
    public void update(float deltaTime) {

    for (Integer id : transforms.keySet()) {
      PVector position = this.transforms.get(id).position;
      RigidBody rigidBody = this.rigidBodies.get(id);

      // Check right boundary
      if (position.x > width - innerBoundary) {
        rigidBody.applyForce(new PVector(-bindForce, 0)); // Push left
      }
      // Check left boundary
      if (position.x < innerBoundary) {
        rigidBody.applyForce(new PVector(bindForce, 0)); // Push right
      }
      // Check bottom boundary
      if (position.y > height - innerBoundary) {
        rigidBody.applyForce(new PVector(0, -bindForce)); // Push up
      }
      // Check top boundary
      if (position.y < innerBoundary) {
        rigidBody.applyForce(new PVector(0, bindForce)); // Push down
      }
    }
  }
}


public class BindCanvasWithTeleport extends System {

  private Map<Integer, Transform> transforms = new HashMap<>();
  private Map<Integer, RigidBody> rigidBodies = new HashMap<>();

  @Override
    protected boolean matchesSystemCriteria(ComponentEvent event) {
    return event.isComponentType(RigidBody.class) && event.entity.hasTag("bindcanvaswithteleport");
  }

  @Override
    protected void onComponentAdded(Entity entity, Component component) {

    Integer ID = entity.getID();
    transforms.put(ID, entity.getComponent(Transform.class));
    rigidBodies.put(ID, (RigidBody)component);
  }

  @Override
    protected void onComponentRemoved(Entity entity, Component component) {
    // Implementation for removing a component from the rendering system // todo for ben, ben thuis is all u buddy
  }

  @Override
    public void update(float deltaTime) {

    for (Integer id : transforms.keySet()) {
      Transform transform = this.transforms.get(id);
      PVector position = transform.position;
      PVector scale = transform.scale;
      RigidBody rigidBody = this.rigidBodies.get(id);  // Assuming you're using this for something

      // Check if the object exceeds the right boundary
      if (position.x > width - scale.x) {
        transform.setPosition(new PVector(-scale.x, position.y));
      }
      // Check if the object goes beyond the left boundary
      if (position.x < -scale.x) {
        transform.setPosition(new PVector(width + scale.x, position.y));
      }

      // Check if the object exceeds the bottom boundary
      if (position.y > height - scale.y) {
        transform.setPosition(new PVector(position.x, -scale.y));
      }
      // Check if the object goes above the top boundary
      if (position.y < -scale.y) {
        transform.setPosition(new PVector(position.x, height + scale.y));
      }
    }
  }
}


  public void settings() { size(1600, 1000); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "ProcessingMockup" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
